# 112981

# Lab 3: Objective of this lab

    - Develop web projects with Spring Boot. Create and persist entities into a relational database using Spring Data.
    - Deploy Spring Boot application in Docker.

## Table of Contents
   1. [Lab3_2_c Answers](#lab3_2_c-answers) 
   2. [Accessing Databases In SpringBoot](#accessing-databases-in-springboot)
   3. [Server-side programming and application servers (Tomcat) - Jakarta EE](#server-side-programming-and-application-servers-tomcat---jakarta-ee)
   4. [Spring Boot - Web development with a full-featured framework](#spring-boot---web-development-with-a-full-featured-framework)
   5. [RESTful web service - quotes](#restful-web-service---quotes)
   6. [References](#references)


## Lab3_2_c Answers

### 1. **The “UserController” class gets an instance of “userRepository” through its constructor; how is this new repository instantiated?**
   
The `UserController` class gets an instance of `userRepository` through **constructor injection**:
```java
public UserController(UserRepository userRepository) {
    this.userRepository = userRepository;
}
```
- This is managed by **Spring's Dependency Injection (DI)** mechanism. 
- **Spring Boot** automatically instantiates the `UserRepository` bean and injects it into the controller, because the `UserRepository` interface is annotated with `@Repository` and extends `CrudRepository`.
- Spring Boot uses **Autowiring** to find the implementation of `UserRepository` (which is generated by Spring Data JPA at runtime) and injects it into the `UserController`.

### 2. **List the methods invoked in the “userRepository” object by the “UserController”. Where are these methods defined?**

The methods invoked on `userRepository` in the `UserController` are:

- `findAll()` – Retrieves all users and is invoked in `showUserList()`:
   ```java
   model.addAttribute("users", userRepository.findAll());
   ```
  
- `save()` – Saves a new or updated `User` entity, and is invoked in `addUser()` and `updateUser()`:
   ```java
   userRepository.save(user);
   ```
  
- `findById()` – Retrieves a specific `User` entity by ID, and is invoked in `showUpdateForm()` and `deleteUser()`:
   ```java
   User user = userRepository.findById(id)
       .orElseThrow(() -> new IllegalArgumentException("Invalid user Id:" + id));
   ```

- `delete()` – Deletes a `User` entity by ID, and is invoked in `deleteUser()`:
   ```java
   userRepository.delete(user);
   ```

These methods are not explicitly defined in the `UserRepository` interface. Instead, they are inherited from the **`CrudRepository`** interface, which `UserRepository` extends. **Spring Data JPA** provides the implementation for these methods at runtime.

### 3. **Where is the data being saved?**

The data is being saved in a **database** configured in the **Spring Boot** application. 

- The `save()` method from `CrudRepository` is responsible for persisting the `User` entity to the database.
- The actual database (e.g., MySQL, H2, PostgreSQL) and its connection details (such as `URL`, `username`, and `password`) are usually defined in the **`application.properties`** or **`application.yml`** file in the Spring Boot project.
- By default, Spring Boot uses an embedded `H2 database` if no other database is specified.

### 4. **Where is the rule for the "not empty" email address defined?**

The rule for the "not empty" email address is defined in the **`User`** entity using the `@NotBlank` annotation:
```java
@NotBlank(message = "Email is mandatory")
private String email;
```

- The `@NotBlank` annotation is a **validation constraint** provided by **Jakarta Bean Validation** (formerly JSR-303/JSR-380). It ensures that the `email` field is not `null`, empty, or consists solely of whitespace.
- This validation is triggered in the `UserController` by the `@Valid` annotation in methods like `addUser()` and `updateUser()`:
```java
public String addUser(@Valid User user, BindingResult result, Model model) { ... }
```

If the validation fails (i.e., if the email is empty or blank), an error message is stored in `BindingResult`, and the user is redirected back to the form (`add-user` template) to correct their input.


# Check full tutorial on: [Baeldung](https://www.baeldung.com/spring-boot-crud-thymeleaf)
## Accessing Databases In SpringBoot

    - Spring Boot makes it easy to create CRUD applications through a layer of standard JPA-based CRUD repositories.
    - We’ll learn how to develop a CRUD web application with Spring Boot and Thymeleaf.

### 1. Maven Dependencies
    
    - Using `spring-boot-starter-parent`, we won’t need to specify the versions of the project dependencies in our pom.xml file, except for overriding the Java version:
    
```xml
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
</parent>
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-thymeleaf</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>
    <dependency>
        <groupId>com.h2database</groupId>
        <artifactId>h2</artifactId>
    </dependency>
</dependencies>
```

### 2. The Domain Layer

    - For simplicity’s sake, this layer will include one single class that will be responsible for modeling `User` entities:

```java
@Entity
public class User {
    
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private long id;
    
    @NotBlank(message = "Name is mandatory")
    private String name;
    
    @NotBlank(message = "Email is mandatory")
    private String email;

    // standard constructors / setters / getters / toString
}
```

    - We’ve annotated the class with the `@Entity` annotation. 
    - Therefore, the JPA implementation, which is `Hibernate`, in this case, will be able to perform `CRUD` operations on the `domain entities` (check [Hibernate 5 with Spring](https://www.baeldung.com/hibernate-spring)).
    - We’ve also constrained the name and email fields with the @NotBlank constraint. 
    - Now, we can use `Hibernate Validator` for validating the constrained fields before persisting or updating an entity in the database (check [associated tutorial on Bean Validation.](https://www.baeldung.com/?__im-QylvkzKT=13326264676159996055)).
    
### 3. The Repository Layer

    - Our sample web application doesn´t do anything yet.
    - Spring Data JPA allows us to implement `JPA-based repositories` (a fancy name for the DAO pattern implementation) with minimal fuss (complicação).
    - [Spring Data JPA](https://www.baeldung.com/the-persistence-layer-with-spring-data-jpa) is a key component of Spring Boot’s `spring-boot-starter-data-jpa`that makes it easy to add CRUD functionality through a powerful `layer of abstraction` placed on top of a JPA implementation. 
    - It allows us to access the persistence layer without having to provide our own DAO implementations from scratch.
    - To provide our application with basic `CRUD functionality` on `User object`s, we just need to `extend the CrudRepository interface`:

```java
@Repository
public interface UserRepository extends CrudRepository<User, Long> {}
```
    - With the CrudRepository interface, Spring Data JPA will provide implementations for the repository’s CRUD methods for us.

### 4. The Controller Layer

    - With the previous the `layer of abstraction`, we can easily add some CRUD functionality to our web application through a basic web tier.
    - In this case, a `single controller class` will suffice for handling `GET` and `POST HTTP` requests and then mapping them to calls to our UserRepository implementation.
    - With this said, yhe controller layer is responsible for `processing user requests` and `building appropriate responses`.
    - The controller class relies on some of [Spring MVC’s](https://www.baeldung.com/spring-mvc-tutorial) key features.
    - Let’s start with the following controller methods:

```java
@Controller
public class UserController {

    // We’ll need a mapping for the /index URL:
    @GetMapping("/index")
    public String showUserList(Model model) {
        model.addAttribute("users", userRepository.findAll());
        return "index";
    }
    
    // Display the user signup form
    @GetMapping("/signup")
    public String showSignUpForm(User user) {
        return "add-user";
    }
    
    // Persist a new entity in the database after validating the constrained fields
    @PostMapping("/adduser")
    public String addUser(@Valid User user, BindingResult result, Model model) {
        if (result.hasErrors()) {
            // If the entity doesn’t pass the validation, the signup form will be redisplayed
            return "add-user";
        }
        
        userRepository.save(user);
        return "redirect:/index";
    }

    // additional CRUD methods

    // We'll also need to fetch the User entity that matches the supplied id from the database.
    @GetMapping("/edit/{id}")
    public String showUpdateForm(@PathVariable("id") long id, Model model) {
        User user = userRepository.findById(id)
          .orElseThrow(() -> new IllegalArgumentException("Invalid user Id:" + id));

        // If the entity exists, it will be passed on as a model attribute to the update form view.
        // The form can be populated with the values of the name and email fields:
        model.addAttribute("user", user);
        return "update-user";
    }


    // Finally, we have the updateUser() and deleteUser() methods within the UserController class.
    // Persist the updated entity in the database
    @PostMapping("/update/{id}")
    public String updateUser(@PathVariable("id") long id, @Valid User user, 
      BindingResult result, Model model) {
        if (result.hasErrors()) {
            user.setId(id);
            return "update-user";
        }

        userRepository.save(user);
        return "redirect:/index";
    }

    // Remove the given entity
    @GetMapping("/delete/{id}")
    public String deleteUser(@PathVariable("id") long id, Model model) {
        User user = userRepository.findById(id)
          .orElseThrow(() -> new IllegalArgumentException("Invalid user Id:" + id));
        userRepository.delete(user);
        return "redirect:/index";
    }

}
```

### 5. The View Layer

    - There’s still a missing component in this schema: `the view layer`.
    - Under the `src/main/resources/templates` folder, we need to `create the HTML templates` required for displaying the list of User entities and the signup and the update forms.
    - We’ll use Thymeleaf as the underlying template engine for parsing the template files.
 
`add-user.html`
```html
<form action="#" th:action="@{/adduser}" th:object="${user}" method="post">
    <label for="name">Name</label>
    <input type="text" th:field="*{name}" id="name" placeholder="Name">
    <span th:if="${#fields.hasErrors('name')}" th:errors="*{name}"></span>
    <label for="email">Email</label>
    <input type="text" th:field="*{email}" id="email" placeholder="Email">
    <span th:if="${#fields.hasErrors('email')}" th:errors="*{email}"></span>
    <input type="submit" value="Add User">   
</form>
```
**Note**: *Notice how we’ve used the `@{/adduser}` URL expression to specify the `form’s action attribute` and the `${}` variable expressions for `embedding dynamic content` in the template, such as the `values of the name and email fields` and the `post-validation errors`.*

`update-user.html`
```html
<form action="#" 
  th:action="@{/update/{id}(id=${user.id})}" 
  th:object="${user}" 
  method="post">
    <label for="name">Name</label>
    <input type="text" th:field="*{name}" id="name" placeholder="Name">
    <span th:if="${#fields.hasErrors('name')}" th:errors="*{name}"></span>
    <label for="email">Email</label>
    <input type="text" th:field="*{email}" id="email" placeholder="Email">
    <span th:if="${#fields.hasErrors('email')}" th:errors="*{email}"></span>
    <input type="submit" value="Update User">   
</form>
```

`index.html` - Displays the list of persisted entities along with the links for editing and removing existing ones.
```html
<div th:switch="${users}">
    <h2 th:case="null">No users yet!</h2>
        <div th:case="*">
            <h2>Users</h2>
            <table>
                <thead>
                    <tr>
                        <th>Name</th>
                        <th>Email</th>
                        <th>Edit</th>
                        <th>Delete</th>
                    </tr>
                </thead>
                <tbody>
                <tr th:each="user : ${users}">
                    <td th:text="${user.name}"></td>
                    <td th:text="${user.email}"></td>
                    <td><a th:href="@{/edit/{id}(id=${user.id})}">Edit</a></td>
                    <td><a th:href="@{/delete/{id}(id=${user.id})}">Delete</a></td>
                </tr>
            </tbody>
        </table>
    </div>      
    <p><a href="/signup">Add a new user</a></p>
</div>
```

    - To give the templates an improved, eye-catching look without spending too much time on HTML/CSS, we can easily use a free [Twitter Bootstrap UI kit](https://getbootstrap.com/), such as [Shards](https://designrevision.com/downloads/shards/).

### 6. Running the Application

    - Let’s define the application’s entry point.
    - Like most Spring Boot applications, we can do this with a `main()` method:
    
```java
@SpringBootApplication
public class Application {

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
```

    - We can now run the application by executing the `main()` method.
    - The application will be available at `http://localhost:8080/index`.
    - We should see a basic CRUD user dashboard with links for adding new entities and for editing and removing existing ones.

